<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter SDK Tester</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>OpenRouter SDK Tester</h1>
            <div class="api-key-container">
                <label for="api-key">API Key:</label>
                <input type="password" id="api-key" placeholder="Enter your OpenRouter API key">
                <button id="save-api-key">Save</button>
            </div>
        </header>

        <div class="tabs">
            <button class="tab-button active" data-tab="chat">Chat Completions</button>
            <button class="tab-button" data-tab="stream">Streaming Chat</button>
            <button class="tab-button" data-tab="embeddings">Embeddings</button>
            <button class="tab-button" data-tab="images">Image Generation</button>
            <button class="tab-button" data-tab="audio">Audio Transcription</button>
            <button class="tab-button" data-tab="functions">Function Calling</button>
            <button class="tab-button" data-tab="agents">Agent Orchestration</button>
            <button class="tab-button" data-tab="vectordb">Vector DB</button>
            <button class="tab-button" data-tab="knowledgeagents">Knowledge Agents</button>
        </div>

        <div class="tab-content">
            <!-- Chat Completions Tab -->
            <div class="tab-pane active" id="chat-tab">
                <h2>Chat Completions</h2>
                <div class="form-group">
                    <label for="chat-model">Model:</label>
                    <select id="chat-model">
                        <option value="openai/gpt-3.5-turbo">OpenAI GPT-3.5 Turbo</option>
                        <option value="openai/gpt-4o">OpenAI GPT-4o</option>
                        <option value="anthropic/claude-3-opus">Anthropic Claude 3 Opus</option>
                        <option value="anthropic/claude-3-sonnet">Anthropic Claude 3 Sonnet</option>
                        <option value="anthropic/claude-3-haiku">Anthropic Claude 3 Haiku</option>
                        <option value="meta-llama/llama-3-70b-instruct">Meta Llama 3 70B Instruct</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="chat-temperature">Temperature:</label>
                    <input type="range" id="chat-temperature" min="0" max="1" step="0.1" value="0.7">
                    <span id="chat-temperature-value">0.7</span>
                </div>
                <div class="form-group">
                    <label for="chat-max-tokens">Max Tokens:</label>
                    <input type="number" id="chat-max-tokens" min="1" max="4096" value="1000">
                </div>
                <div class="form-group">
                    <label for="chat-system-message">System Message:</label>
                    <textarea id="chat-system-message" rows="2" placeholder="You are a helpful assistant."></textarea>
                </div>
                <div class="chat-container">
                    <div class="chat-messages" id="chat-messages">
                        <!-- Messages will be added here -->
                    </div>
                    <div class="chat-input-container">
                        <textarea id="chat-input" placeholder="Type your message here..."></textarea>
                        <button id="chat-send">Send</button>
                    </div>
                </div>
            </div>

            <!-- Streaming Chat Tab -->
            <div class="tab-pane" id="stream-tab">
                <h2>Streaming Chat</h2>
                <div class="form-group">
                    <label for="stream-model">Model:</label>
                    <select id="stream-model">
                        <option value="openai/gpt-3.5-turbo">OpenAI GPT-3.5 Turbo</option>
                        <option value="openai/gpt-4o">OpenAI GPT-4o</option>
                        <option value="anthropic/claude-3-opus">Anthropic Claude 3 Opus</option>
                        <option value="anthropic/claude-3-sonnet">Anthropic Claude 3 Sonnet</option>
                        <option value="anthropic/claude-3-haiku">Anthropic Claude 3 Haiku</option>
                        <option value="meta-llama/llama-3-70b-instruct">Meta Llama 3 70B Instruct</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="stream-temperature">Temperature:</label>
                    <input type="range" id="stream-temperature" min="0" max="1" step="0.1" value="0.7">
                    <span id="stream-temperature-value">0.7</span>
                </div>
                <div class="form-group">
                    <label for="stream-max-tokens">Max Tokens:</label>
                    <input type="number" id="stream-max-tokens" min="1" max="4096" value="1000">
                </div>
                <div class="form-group">
                    <label for="stream-system-message">System Message:</label>
                    <textarea id="stream-system-message" rows="2" placeholder="You are a helpful assistant."></textarea>
                </div>
                <div class="chat-container">
                    <div class="chat-messages" id="stream-messages">
                        <!-- Messages will be added here -->
                    </div>
                    <div class="chat-input-container">
                        <textarea id="stream-input" placeholder="Type your message here..."></textarea>
                        <button id="stream-send">Send</button>
                    </div>
                </div>
            </div>

            <!-- Embeddings Tab -->
            <div class="tab-pane" id="embeddings-tab">
                <h2>Embeddings</h2>
                <div class="form-group">
                    <label for="embedding-model">Model:</label>
                    <select id="embedding-model">
                        <option value="openai/text-embedding-3-small">OpenAI Text Embedding 3 Small</option>
                        <option value="openai/text-embedding-3-large">OpenAI Text Embedding 3 Large</option>
                        <option value="openai/text-embedding-ada-002">OpenAI Text Embedding Ada 002</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="embedding-input">Input Text:</label>
                    <textarea id="embedding-input" rows="5" placeholder="Enter text to generate embeddings for..."></textarea>
                </div>
                <button id="embedding-generate">Generate Embeddings</button>
                <div class="result-container">
                    <h3>Results:</h3>
                    <div id="embedding-result" class="result">
                        <!-- Embedding results will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Image Generation Tab -->
            <div class="tab-pane" id="images-tab">
                <h2>Image Generation</h2>
                <div class="form-group">
                    <label for="image-model">Model:</label>
                    <select id="image-model">
                        <option value="openai/dall-e-3">OpenAI DALL-E 3</option>
                        <option value="stability/stable-diffusion-xl">Stability Stable Diffusion XL</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="image-prompt">Prompt:</label>
                    <textarea id="image-prompt" rows="3" placeholder="Describe the image you want to generate..."></textarea>
                </div>
                <div class="form-group">
                    <label for="image-size">Size:</label>
                    <select id="image-size">
                        <option value="1024x1024">1024x1024</option>
                        <option value="1024x1792">1024x1792</option>
                        <option value="1792x1024">1792x1024</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="image-quality">Quality:</label>
                    <select id="image-quality">
                        <option value="standard">Standard</option>
                        <option value="hd">HD</option>
                    </select>
                </div>
                <button id="image-generate">Generate Image</button>
                <div class="result-container">
                    <h3>Generated Image:</h3>
                    <div id="image-result" class="image-result">
                        <!-- Generated image will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Audio Transcription Tab -->
            <div class="tab-pane" id="audio-tab">
                <h2>Audio Transcription</h2>
                <div class="form-group">
                    <label for="audio-model">Model:</label>
                    <select id="audio-model">
                        <option value="openai/whisper-1">OpenAI Whisper</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="audio-file">Audio File:</label>
                    <input type="file" id="audio-file" accept="audio/*">
                </div>
                <div class="form-group">
                    <label for="audio-language">Language (optional):</label>
                    <input type="text" id="audio-language" placeholder="en">
                </div>
                <button id="audio-transcribe">Transcribe Audio</button>
                <div class="result-container">
                    <h3>Transcription:</h3>
                    <div id="audio-result" class="result">
                        <!-- Transcription results will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Function Calling Tab -->
            <div class="tab-pane" id="functions-tab">
                <h2>Function Calling</h2>
                <div class="form-group">
                    <label for="function-model">Model:</label>
                    <select id="function-model">
                        <option value="openai/gpt-4o">OpenAI GPT-4o</option>
                        <option value="anthropic/claude-3-opus">Anthropic Claude 3 Opus</option>
                        <option value="anthropic/claude-3-sonnet">Anthropic Claude 3 Sonnet</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="function-definitions">Function Definitions (JSON):</label>
                    <textarea id="function-definitions" rows="10">[
  {
    "name": "get_weather",
    "description": "Get the current weather in a location",
    "parameters": {
      "type": "object",
      "properties": {
        "location": {
          "type": "string",
          "description": "The city and state, e.g. San Francisco, CA"
        },
        "unit": {
          "type": "string",
          "enum": ["celsius", "fahrenheit"],
          "description": "The temperature unit to use"
        }
      },
      "required": ["location"]
    }
  }
]</textarea>
                </div>
                <div class="form-group">
                    <label for="function-prompt">User Prompt:</label>
                    <textarea id="function-prompt" rows="3">What's the weather like in San Francisco?</textarea>
                </div>
                <button id="function-call">Call Functions</button>
                <div class="result-container">
                    <h3>Results:</h3>
                    <div id="function-result" class="result">
                        <!-- Function call results will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Agent Orchestration Tab -->
            <div class="tab-pane" id="agents-tab">
                <h2>Agent Orchestration</h2>
                <div class="form-group">
                    <label for="agent-config">Agent Configuration (JSON):</label>
                    <textarea id="agent-config" rows="10">{
  "agents": [
    {
      "id": "researcher",
      "name": "Research Specialist",
      "description": "Expert at finding information",
      "model": "anthropic/claude-3-opus",
      "systemMessage": "You are a research specialist who excels at finding accurate information."
    },
    {
      "id": "writer",
      "name": "Content Writer",
      "description": "Expert at writing content",
      "model": "openai/gpt-4o",
      "systemMessage": "You are a content writer who creates engaging and informative content."
    }
  ],
  "tasks": [
    {
      "id": "research-task",
      "name": "Research Task",
      "description": "Research the current market trends for electric vehicles",
      "assignedAgentId": "researcher"
    },
    {
      "id": "writing-task",
      "name": "Writing Task",
      "description": "Write an article about electric vehicles based on the research",
      "assignedAgentId": "writer"
    }
  ],
  "workflow": {
    "id": "research-workflow",
    "name": "Research and Write",
    "dependencies": {
      "writing-task": ["research-task"]
    }
  }
}</textarea>
                </div>
                <button id="agent-run">Run Workflow</button>
                <div class="result-container">
                    <h3>Results:</h3>
                    <div id="agent-result" class="result">
                        <!-- Agent orchestration results will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Vector DB Tab -->
            <div class="tab-pane" id="vectordb-tab">
                <h2>Vector Database</h2>
                <div class="form-group">
                    <label for="vectordb-action">Action:</label>
                    <select id="vectordb-action">
                        <option value="create">Create Vector DB</option>
                        <option value="add">Add Documents</option>
                        <option value="search">Search</option>
                    </select>
                </div>
                
                <!-- Create Vector DB Form -->
                <div id="vectordb-create-form" class="vectordb-form">
                    <div class="form-group">
                        <label for="vectordb-id">Vector DB ID:</label>
                        <input type="text" id="vectordb-id" placeholder="my-vector-db" value="default-db">
                    </div>
                    <div class="form-group">
                        <label for="vectordb-dimensions">Dimensions:</label>
                        <input type="number" id="vectordb-dimensions" value="1536">
                    </div>
                    <div class="form-group">
                        <label for="vectordb-metric">Similarity Metric:</label>
                        <select id="vectordb-metric">
                            <option value="cosine">Cosine</option>
                            <option value="euclidean">Euclidean</option>
                            <option value="dot">Dot Product</option>
                        </select>
                    </div>
                </div>
                
                <!-- Add Documents Form -->
                <div id="vectordb-add-form" class="vectordb-form" style="display: none;">
                    <div class="form-group">
                        <label for="vectordb-add-id">Vector DB ID:</label>
                        <input type="text" id="vectordb-add-id" placeholder="my-vector-db" value="default-db">
                    </div>
                    <div class="form-group">
                        <label for="vectordb-documents">Documents (JSON):</label>
                        <textarea id="vectordb-documents" rows="8">[
  {
    "id": "doc1",
    "content": "Electric vehicles are becoming increasingly popular.",
    "metadata": { "source": "research", "topic": "ev" }
  },
  {
    "id": "doc2",
    "content": "Solar panels can be used to charge electric vehicles.",
    "metadata": { "source": "research", "topic": "ev" }
  }
]</textarea>
                    </div>
                </div>
                
                <!-- Search Form -->
                <div id="vectordb-search-form" class="vectordb-form" style="display: none;">
                    <div class="form-group">
                        <label for="vectordb-search-id">Vector DB ID:</label>
                        <input type="text" id="vectordb-search-id" placeholder="my-vector-db" value="default-db">
                    </div>
                    <div class="form-group">
                        <label for="vectordb-query">Search Query:</label>
                        <input type="text" id="vectordb-query" placeholder="electric vehicle charging" value="electric vehicle">
                    </div>
                    <div class="form-group">
                        <label for="vectordb-limit">Limit:</label>
                        <input type="number" id="vectordb-limit" value="5">
                    </div>
                </div>
                
                <button id="vectordb-execute">Execute</button>
                <div class="result-container">
                    <h3>Results:</h3>
                    <div id="vectordb-result" class="result">
                        <!-- Vector DB results will be shown here -->
                    </div>
                </div>
            </div>

            <!-- Knowledge Agents Tab -->
            <div class="tab-pane" id="knowledgeagents-tab">
                <h2>Knowledge Agents</h2>
                <p>This tab demonstrates agents that use vector databases for knowledge retrieval.</p>
                
                <div class="form-group">
                    <label for="agent-knowledge-id">Agent ID:</label>
                    <input type="text" id="agent-knowledge-id" value="researcher">
                </div>
                
                <div class="form-group">
                    <label for="agent-knowledge-docs">Knowledge Documents (JSON):</label>
                    <textarea id="agent-knowledge-docs" rows="8">[
  {
    "id": "ev-market-1",
    "content": "Electric vehicle sales have grown by 40% year-over-year globally, with China, Europe, and the US being the largest markets.",
    "metadata": { "source": "market-report", "topic": "electric-vehicles", "date": "2024-02-15" }
  },
  {
    "id": "ev-market-2",
    "content": "Battery technology improvements have reduced costs by 80% over the past decade, making electric vehicles more affordable for consumers.",
    "metadata": { "source": "technology-report", "topic": "electric-vehicles", "date": "2024-01-10" }
  },
  {
    "id": "ev-market-3",
    "content": "Major automakers have committed to transitioning their fleets to electric vehicles, with many planning to be fully electric by 2035.",
    "metadata": { "source": "industry-news", "topic": "electric-vehicles", "date": "2024-03-01" }
  },
  {
    "id": "ev-market-4",
    "content": "Charging infrastructure has expanded significantly, with over 1.8 million public charging stations worldwide, a 40% increase from the previous year.",
    "metadata": { "source": "infrastructure-report", "topic": "electric-vehicles", "date": "2024-02-28" }
  }
]</textarea>
                </div>
                
                <button id="add-agent-knowledge">Add Knowledge to Agent</button>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label for="agent-knowledge-query">Search Agent Knowledge:</label>
                    <input type="text" id="agent-knowledge-query" value="electric vehicle market">
                </div>
                
                <button id="search-agent-knowledge">Search Agent Knowledge</button>
                
                <div class="result-container">
                    <h3>Search Results:</h3>
                    <div id="agent-knowledge-result" class="result">
                        <!-- Search results will be shown here -->
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <h3>Run Workflow with Knowledge-Enabled Agents</h3>
                    <p>This will run a workflow where agents use their knowledge base to complete tasks.</p>
                    
                    <div class="form-group">
                        <label for="knowledge-workflow-config">Workflow Configuration (JSON):</label>
                        <textarea id="knowledge-workflow-config" rows="10">{
  "agents": [
    {
      "id": "researcher",
      "name": "Research Specialist",
      "description": "Expert at finding information using knowledge base",
      "model": "anthropic/claude-3-opus",
      "systemMessage": "You are a research specialist who uses a knowledge base to find accurate information."
    },
    {
      "id": "analyst",
      "name": "Market Analyst",
      "description": "Expert at analyzing market trends",
      "model": "openai/gpt-4o",
      "systemMessage": "You are a market analyst who analyzes research data to identify trends and insights."
    }
  ],
  "tasks": [
    {
      "id": "research-ev-market",
      "name": "Research EV Market",
      "description": "Research the current market trends for electric vehicles",
      "assignedAgentId": "researcher"
    },
    {
      "id": "analyze-ev-market",
      "name": "Analyze EV Market",
      "description": "Analyze the electric vehicle market data and identify key trends",
      "assignedAgentId": "analyst"
    }
  ],
  "workflow": {
    "id": "ev-market-analysis",
    "name": "EV Market Analysis",
    "dependencies": {
      "analyze-ev-market": ["research-ev-market"]
    }
  }
}</textarea>
                    </div>
                    
                    <button id="run-knowledge-workflow">Run Knowledge Workflow</button>
                    
                    <div class="result-container">
                        <h3>Workflow Results:</h3>
                        <div id="knowledge-workflow-result" class="result">
                            <!-- Workflow results will be shown here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import the OpenRouter SDK -->
    <script>
        // Mock ChromaClient for testing purposes
        class ChromaClient {
            constructor() {
                this.collections = new Map();
                console.log('Mock ChromaClient initialized');
            }
            
            async listCollections() {
                console.log('Listing collections');
                return Array.from(this.collections.values()).map(c => ({ name: c.name }));
            }
            
            async createCollection(params) {
                console.log('Creating collection:', params);
                if (!this.collections.has(params.name)) {
                    const collection = {
                        name: params.name,
                        metadata: params.metadata || {},
                        documents: [],
                        embeddings: [],
                        metadatas: [],
                        ids: []
                    };
                    this.collections.set(params.name, collection);
                }
                return this.getCollection(params.name);
            }
            
            async getCollection(name) {
                console.log('Getting collection:', name);
                if (!this.collections.has(name)) {
                    await this.createCollection({ name });
                }
                
                const collection = this.collections.get(name);
                
                return {
                    name,
                    add: async (params) => {
                        console.log(`Adding to collection ${name}:`, params);
                        for (let i = 0; i < params.ids.length; i++) {
                            collection.ids.push(params.ids[i]);
                            collection.documents.push(params.documents[i]);
                            collection.embeddings.push(params.embeddings[i]);
                            collection.metadatas.push(params.metadatas[i]);
                        }
                        return params.ids;
                    },
                    query: async (params) => {
                        console.log(`Querying collection ${name}:`, params);
                        const limit = params.nResults || 5;
                        
                        // For mock purposes, just return the most recent documents
                        const resultIds = [];
                        const resultDocuments = [];
                        const resultMetadatas = [];
                        const resultDistances = [];
                        
                        // Get the last 'limit' items or all if less than limit
                        const count = Math.min(limit, collection.ids.length);
                        const startIdx = Math.max(0, collection.ids.length - count);
                        
                        if (count > 0) {
                            resultIds.push(collection.ids.slice(startIdx));
                            resultDocuments.push(collection.documents.slice(startIdx));
                            resultMetadatas.push(collection.metadatas.slice(startIdx));
                            
                            // Generate random distances
                            const distances = [];
                            for (let i = 0; i < count; i++) {
                                distances.push(Math.random() * 0.2); // Random distance between 0 and 0.2
                            }
                            resultDistances.push(distances);
                        } else {
                            resultIds.push([]);
                            resultDocuments.push([]);
                            resultMetadatas.push([]);
                            resultDistances.push([]);
                        }
                        
                        return {
                            ids: resultIds,
                            documents: resultDocuments,
                            metadatas: resultMetadatas,
                            distances: resultDistances
                        };
                    }
                };
            }
        }
        
        // Mock OpenRouter SDK for testing purposes
        // In a real application, you would use the actual SDK
        class OpenRouter {
            constructor(config) {
                this.config = config;
                console.log('OpenRouter initialized with config:', config);
            }

            async createChatCompletion(options) {
                console.log('Creating chat completion with options:', options);
                // Mock response
                return {
                    id: 'mock-completion-id',
                    model: options.model,
                    choices: [
                        {
                            message: {
                                role: 'assistant',
                                content: `This is a mock response from ${options.model}. In a real application, this would be generated by the AI model.`
                            },
                            finish_reason: 'stop',
                            index: 0
                        }
                    ],
                    usage: {
                        prompt_tokens: 100,
                        completion_tokens: 50,
                        total_tokens: 150
                    }
                };
            }

            async *streamChatCompletions(options) {
                console.log('Streaming chat completions with options:', options);
                // Mock streaming response
                const response = `This is a mock streaming response from ${options.model}. In a real application, this would be generated by the AI model.`;
                const words = response.split(' ');
                
                for (const word of words) {
                    yield {
                        choices: [
                            {
                                delta: {
                                    content: word + ' '
                                },
                                index: 0
                            }
                        ]
                    };
                    // Simulate delay
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }

            async createEmbedding(options) {
                console.log('Creating embedding with options:', options);
                // Mock embedding response
                return {
                    id: 'mock-embedding-id',
                    object: 'embedding',
                    data: [
                        {
                            embedding: Array(1536).fill(0).map(() => Math.random() * 2 - 1),
                            index: 0,
                            object: 'embedding'
                        }
                    ],
                    model: options.model,
                    usage: {
                        prompt_tokens: 50,
                        total_tokens: 50
                    }
                };
            }

            async createImage(options) {
                console.log('Creating image with options:', options);
                // Mock image response
                return {
                    created: Date.now(),
                    data: [
                        {
                            url: 'https://placehold.co/1024x1024/EEE/31343C?text=Mock+Image',
                            revised_prompt: options.prompt
                        }
                    ]
                };
            }

            async createTranscription(options) {
                console.log('Creating transcription with options:', options);
                // Mock transcription response
                return {
                    text: 'This is a mock transcription. In a real application, this would be the transcribed text from the audio file.'
                };
            }

            async createVectorDb(config) {
                console.log('Creating vector DB with config:', config);
                // Mock vector DB
                return {
                    addDocument: async (doc, namespace) => {
                        console.log('Adding document to vector DB:', doc, namespace);
                        return doc.id || 'mock-doc-id';
                    },
                    addDocuments: async (docs, namespace) => {
                        console.log('Adding documents to vector DB:', docs, namespace);
                        return docs.map(doc => doc.id || 'mock-doc-id');
                    },
                    searchByText: async (text, options) => {
                        console.log('Searching vector DB:', text, options);
                        return [
                            {
                                score: 0.95,
                                document: {
                                    id: 'mock-doc-1',
                                    content: 'This is a mock search result related to ' + text,
                                    metadata: { source: 'mock' }
                                }
                            }
                        ];
                    }
                };
            }
        }

        // Mock AIOrchestrator class
        class AIOrchestrator {
            constructor(config) {
                this.config = config;
                this.openRouter = new OpenRouter(config);
                this.chromaClient = new ChromaClient();
                this.agentCollections = new Map(); // Map to store agent Chroma collections
                this.vectorDbCollections = new Map(); // Map to store vector DB Chroma collections
                console.log('AIOrchestrator initialized with config:', config);
                
                // Initialize Chroma client
                this.initializeChroma();
            }
            
            async initializeChroma() {
                try {
                    console.log('Initializing Chroma client...');
                    // Create a default collection for testing
                    await this.createChromaCollection('default-collection');
                    console.log('Chroma initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize Chroma:', error);
                }
            }
            
            async createChromaCollection(name) {
                try {
                    // Check if collection exists
                    const collections = await this.chromaClient.listCollections();
                    const exists = collections.some(c => c.name === name);
                    
                    if (!exists) {
                        // Create collection
                        await this.chromaClient.createCollection({
                            name: name,
                            metadata: { description: `Collection for ${name}` }
                        });
                        console.log(`Created Chroma collection: ${name}`);
                    }
                    
                    // Get collection
                    return await this.chromaClient.getCollection(name);
                } catch (error) {
                    console.error(`Error creating Chroma collection ${name}:`, error);
                    throw error;
                }
            }

            createAgent(config) {
                console.log('Creating agent:', config);
                const agent = { ...config, id: config.id || 'mock-agent-id' };
                
                // Create a Chroma collection for this agent
                this.createChromaCollection(`agent-${agent.id}`).then(collection => {
                    this.agentCollections.set(agent.id, collection);
                }).catch(error => {
                    console.error(`Failed to create collection for agent ${agent.id}:`, error);
                });
                
                return agent;
            }

            createTask(config) {
                console.log('Creating task:', config);
                return { ...config, id: config.id || 'mock-task-id' };
            }

            createWorkflow(config) {
                console.log('Creating workflow:', config);
                return { ...config, id: config.id || 'mock-workflow-id' };
            }

            async createVectorDb(id, config) {
                console.log('Creating vector DB:', id, config);
                
                try {
                    // Create a Chroma collection for this vector DB
                    const collection = await this.createChromaCollection(`vectordb-${id}`);
                    
                    // Create a wrapper around the Chroma collection
                    const vectorDb = {
                        id,
                        config,
                        collection,
                        addDocument: async (doc, namespace) => {
                            console.log('Adding document to Chroma vector DB:', doc, namespace);
                            
                            // Generate a simple embedding (in a real app, we'd use the OpenAI API)
                            const embedding = Array(config.dimensions || 1536).fill(0).map(() => Math.random() * 2 - 1);
                            
                            // Add document to Chroma
                            await collection.add({
                                ids: [doc.id || `doc-${Date.now()}`],
                                embeddings: [embedding],
                                metadatas: [{ ...doc.metadata, namespace, content: doc.content }],
                                documents: [doc.content]
                            });
                            
                            return doc.id || `doc-${Date.now()}`;
                        },
                        addDocuments: async (docs, namespace) => {
                            console.log('Adding documents to Chroma vector DB:', docs, namespace);
                            
                            // Generate simple embeddings
                            const embeddings = docs.map(() => 
                                Array(config.dimensions || 1536).fill(0).map(() => Math.random() * 2 - 1)
                            );
                            
                            // Add documents to Chroma
                            await collection.add({
                                ids: docs.map(doc => doc.id || `doc-${Date.now()}-${Math.random()}`),
                                embeddings: embeddings,
                                metadatas: docs.map(doc => ({ ...doc.metadata, namespace, content: doc.content })),
                                documents: docs.map(doc => doc.content)
                            });
                            
                            return docs.map(doc => doc.id || `doc-${Date.now()}-${Math.random()}`);
                        },
                        searchByText: async (text, options = {}) => {
                            console.log('Searching Chroma vector DB:', text, options);
                            const limit = options.limit || 5;
                            
                            // Generate a simple query embedding
                            const queryEmbedding = Array(config.dimensions || 1536).fill(0).map(() => Math.random() * 2 - 1);
                            
                            // Search Chroma
                            const results = await collection.query({
                                queryEmbeddings: [queryEmbedding],
                                nResults: limit
                            });
                            
                            // Format results
                            const formattedResults = [];
                            if (results.ids && results.ids.length > 0 && results.ids[0].length > 0) {
                                for (let i = 0; i < results.ids[0].length; i++) {
                                    formattedResults.push({
                                        score: 0.8 + Math.random() * 0.2, // Random score between 0.8 and 1.0
                                        document: {
                                            id: results.ids[0][i],
                                            content: results.documents[0][i],
                                            metadata: results.metadatas[0][i]
                                        }
                                    });
                                }
                            }
                            
                            return formattedResults;
                        }
                    };
                    
                    
                this.vectorDbCollections.set(id, vectorDb);
                    return vectorDb;
                } catch (error) {
                    console.error(`Error creating vector DB ${id}:`, error);
                    throw error;
                }
            }
            
            async addAgentKnowledge(agentId, document, namespace) {
                console.log('Adding knowledge to agent:', agentId, document, namespace);
            try {
                    // Get or create agent collection
                    let collection = this.agentCollections.get(agentId);
                    if (!collection) {
                        collection = await this.createChromaCollection(`agent-${agentId}`);
        
                                    this.agentCollections.set(agentId, collection);
                    }
                    
                    // Generate a simple embedding
                    const embedding = Array(1536).fill(0).map(() => Math.random() * 2 - 1);
                    
                    // Add document to Chroma
                    await collection.add({
                        ids: [document.id || `doc-${Date.now()}`],
                        embeddings: [embedding],
                        metadatas: [{ ...document.metadata, namespace, content: document.content }],
                        documents: [document.content]
                    });
                    
                    return document.id || `doc-${Date.now()}`;
                } catch (error) {
                    console.error(`Error adding knowledge to agent ${agentId}:`, error);
                    throw error;
                }
            }
            
            async addAgentKnowledgeBatch(agentId, documents, namespace) {
                console.log('Adding knowledge batch to agent:', agentId, documents, namespace);
                
                    try {
                    // Get or create agent collection
                    let collection = this.agentCollections.get(agentId);
                    if (!collection) {
                        collection = await this.createChromaCollection(`agent-${agentId}`);
                    this.agentCollections.set(agentId, collection);
                    }
                    
                    // Generate simple embeddings
                    const embeddings = documents.map(() => 
                        Array(1536).fill(0).map(() => Math.random() * 2 - 1)
                    );
                    
                    // Add documents to Chroma
                    const docIds = documents.map(doc => doc.id || `doc-${Date.now()}-${Math.random()}`);
                    await collection.add({
                        ids: docIds,
                        embeddings: embeddings,
                        metadatas: documents.map(doc => ({ ...doc.metadata, namespace, content: doc.content })),
                        documents: documents.map(doc => doc.content)
                    });
                    
                    return docIds;
                } catch (error) {
                    console.error(`Error adding knowledge batch to agent ${agentId}:`, error);
                    throw error;
                }
            }
            
            async searchAgentKnowledge(agentId, text, options = {}) {
                console.log('Searching agent knowledge:', agentId, text, options);
                
                try {
                    // Get agent collection
                    const collection = this.agentCollections.get(agentId);
                    if (!collection) {
                        return [];
                    }
                    
                    const limit = options.limit || 5;
                    
                    // Generate a simple query embedding
                    const queryEmbedding = Array(1536).fill(0).map(() => Math.random() * 2 - 1);
                    
                    // Search Chroma
                    const results = await collection.query({
                        queryEmbeddings: [queryEmbedding],
                        nResults: limit
                    });
                    
                    // Format results
                    const formattedResults = [];
                    if (results.ids && results.ids.length > 0 && results.ids[0].length > 0) {
                        for (let i = 0; i < results.ids[0].length; i++) {
                            formattedResults.push({
                                score: 0.8 + Math.random() * 0.2, // Random score between 0.8 and 1.0
                                document: {
                                    id: results.ids[0][i],
                                    content: results.documents[0][i],
                                    metadata: results.metadatas[0][i]
                                }
                            });
                        }
                    }
                    
                    return formattedResults;
                } catch (error) {
                    console.error(`Error searching agent knowledge for ${agentId}:`, error);
                    throw error;
                }
            }

            async executeWorkflow(workflow) {
                console.log('Executing workflow:', workflow);
                
                // Get all agents involved in the workflow
                const agentIds = new Set(workflow.tasks.map(task => task.assignedAgentId));
                
                const results = {};
                
                // Execute each task
                for (const task of workflow.tasks) {
                    const agentId = task.assignedAgentId;
                    
                    try {
                        // Check if agent has a Chroma collection
                        const hasKnowledge = this.agentCollections.has(agentId);
                        
                        if (hasKnowledge) {
                            // Search for relevant knowledge
                            const collection = this.agentCollections.get(agentId);
                            
                            // Generate a simple query embedding
                            const queryEmbedding = Array(1536).fill(0).map(() => Math.random() * 2 - 1);
                            
                            // Search Chroma
                            const searchResults = await collection.query({
                                queryEmbeddings: [queryEmbedding],
                                nResults: 5
                            });
                            
                            // Extract relevant knowledge
                            let relevantKnowledge = '';
                            let knowledgeCount = 0;
                            
                            if (searchResults.documents && searchResults.documents.length > 0 && searchResults.documents[0].length > 0) {
                                relevantKnowledge = searchResults.documents[0].join('\n\n');
                                knowledgeCount = searchResults.documents[0].length;
                            }
                            
                            results[task.id] = {
                                taskId: task.id,
                                agentId: agentId,
                                output: `Task completed using Chroma vector database:\n\nRelevant information:\n${relevantKnowledge}\n\nAnalysis based on knowledge:\nBased on the information retrieved from Chroma, I've completed the task "${task.description}". The analysis shows that electric vehicles are becoming increasingly popular, with growing market trends and technological advancements.`,
                                status: 'completed',
                                usedKnowledge: true,
                                knowledgeCount: knowledgeCount
                            };
                        } else {
                            // Standard mock response without knowledge
                            results[task.id] = {
                                taskId: task.id,
                                agentId: agentId,
                                output: `Mock output for task ${task.id} executed by agent ${agentId}. No Chroma knowledge base was available for this task.`,
                                status: 'completed',
                                usedKnowledge: false
                            };
                        }
                    } catch (error) {
                        console.error(`Error executing task ${task.id}:`, error);
                        results[task.id] = {
                            taskId: task.id,
                            agentId: agentId,
                            output: `Error executing task: ${error.message}`,
                            status: 'error',
                            usedKnowledge: false
                        };
                    }
                }
                
                return results;
            }
        }
    </script>
    
    <script src="app.js"></script>
</body>
</html>